#include "pch.h"

#include "../Common/StreamVInt.h"
#include "../Common/OpBitsCompression.h"
#include "../Common/FrontierCompression.h"
#include "../Common/Util.h"

#include <vector>

TEST(TestFrontierCompression, TestBitmapCompression) {
	std::vector<uint32_t> indexes = { 7, 8, 32, 39, 177, 999, 1000, 1001, 1002, 1005 };
	std::vector<uint8_t> buffer(4096);
	int encodedSize = 
		FrontierCompression::EncodeBitMap(int(indexes.size()), &indexes[0], &buffer[0], int(buffer.size()));

	std::vector<uint32_t> newindexes(1024);
	int size = encodedSize;
	int valsCount = FrontierCompression::DecodeBitMap(size, &buffer[0], &newindexes[0], int(newindexes.size()));
	EXPECT_EQ(valsCount, indexes.size());
	for (int i = 0; i < indexes.size(); i++) {
		EXPECT_EQ(newindexes[i], indexes[i]);
	}
}

TEST(TestFrontierCompression, TestCompression_StreamVInt) {
	std::vector<uint32_t> indexes;
	for (int i = 0; i < 150; i++) {
		indexes.push_back(i * 11);
	}
	std::vector<uint8_t> buffer(1024*1024);
	int encodedSize =
		FrontierCompression::Encode(int(indexes.size()), &indexes[0], &buffer[0], int(buffer.size()));
	EXPECT_EQ(FrontierCompression::IsBitMap(&buffer[0]), false);
	std::vector<uint32_t> newindexes(1024);
	int size = encodedSize;
	int valsCount = FrontierCompression::Decode(size, &buffer[0], &newindexes[0], int(newindexes.size()));
	EXPECT_EQ(valsCount, indexes.size());
	for (int i = 0; i < indexes.size(); i++) {
		EXPECT_EQ(newindexes[i], i * 11);
	}
}

TEST(TestFrontierCompression, TestCompression_Map) {
	std::vector<uint32_t> indexes;
	for (int i = 0; i < 150; i++) {
		indexes.push_back(i * 7);
	}
	std::vector<uint8_t> buffer(4096);
	int encodedSize =
		FrontierCompression::Encode(int(indexes.size()), &indexes[0], &buffer[0], int(buffer.size()));
	EXPECT_EQ(FrontierCompression::IsBitMap(&buffer[0]), true);
	std::vector<uint32_t> newindexes(1024);
	int size = encodedSize;
	int valsCount = FrontierCompression::Decode(size, &buffer[0], &newindexes[0], int(newindexes.size()));
	EXPECT_EQ(valsCount, indexes.size());
	for (int i = 0; i < indexes.size(); i++) {
		EXPECT_EQ(newindexes[i], indexes[i]);
	}
}

TEST(TestFrontierCompression, TestCompression_WithCheck) {
	std::vector<uint32_t> indexes;
	for (int i = 0; i < 150; i++) {
		indexes.push_back(i * 7);
	}
	indexes.push_back(700);
	auto orig_indexes = indexes;
	std::vector<uint8_t> buffer(1024*1024);
	int encodedSize =
		FrontierCompression::EncodeWithCheck(int(indexes.size()), &indexes[0], &buffer[0], int(buffer.size()));
	EXPECT_EQ(FrontierCompression::IsBitMap(&buffer[0]), false);
	std::vector<uint32_t> newindexes(1024);
	int size = encodedSize;
	int valsCount = FrontierCompression::Decode(size, &buffer[0], &newindexes[0], int(newindexes.size()));
	EXPECT_EQ(valsCount, indexes.size());
	for (int i = 0; i < indexes.size(); i++) {
		EXPECT_EQ(newindexes[i], orig_indexes[i]);
	}
}

TEST(TestFrontierCompression, TectCompression_LargeRange) {
	std::string str = "12884901909 12884901930 12884901951 12884901954 12884901955 12884901958 12884901959 12884901960 12884901961 12884901962 12884901964 12884901965 12884901967 12884901984 12884901985 12884901986 12884901988 12884901989 12884901991 12884901992 12884901995 12884901997 12884901998 12884901999 12884902000 12884902001 12884902003 12884902004 12884902005 12884902006 12884902009 12884902010 12884902011 12884902012 12884902014 12884902017 12884902019 12884902020 12884902021 12884902022 12884902025 12884902027 12884902028 12884902030 12884902031 12884902032 12884902033 12884902034 12884902036 12884902039 12884902040 12884902042 12884902043 12884902045 12884902046 12884902047 12884902064 12884902066 12884902067 12884902069 12884902070 12884902071 12884902072 12884902073 12884902074 12884902076 12884902077 12884902081 12884902082 12884902084 12884902085 12884902087 12884902088 12884902090 12884902091 12884902093 12884902094 12884902096 12884902097 12884902099 12884902100 12884902102 12884902105 12884902106 12884902107 12884902108 12884902110 12884902111 12884902112 12884902114 12884902115 12884902117 12884902118 12884902119 12884902120 12884902121 12884902124 12884902125 12884902127 12884902145 12884902146 12884902147 12884902148 12884902149 12884902160 12884902161 12884902401 12884902402 12884902403 12884902408 12884902410 12884902432 12884902434 12884902657 12884902658 12884902659 12884902668 12884902671 12884902704 12884902707 12884902913 12884902914 12884902915 12884902916 12884902928 12884903937 12884903938 12884903939 12884903944 12884903968 12884904961 12884904962 12884904963 12884904972 12884905008 12884967424 12885032960 12885098496 12952010753 12952010754 12952010755 13019119617 13019119618 13019119619 13086228484 13086228486 13086228487 13086228488 13086228489 13086228491 13086228492 13086228493 13086228494 13086228496 13086228512 13086228528 16978542543 16978542559 16978542575 16978542577 16978542578 16978542579 16978542580 16978542582 16978542583 16978542584 16978542585 16978542587 17045651452 17045651453 17045651454 17112760316 17112760317 17112760318 17179672575 17179738111 17179803647 17179866063 17179866099 17179866108 17179866109 17179866110 17179867103 17179867127 17179867132 17179867133 17179867134 17179868143 17179868155 17179868156 17179868157 17179868158 17179868364 17179868367 17179868400 17179868403 17179868412 17179868413 17179868414 17179868637 17179868639 17179868661 17179868663 17179868668 17179868669 17179868670 17179868910 17179868911 17179868922 17179868923 17179868924 17179868925 17179868926 17179868944 17179868946 17179868947 17179868950 17179868951 17179868952 17179868953 17179868954 17179868956 17179868957 17179868959 17179868960 17179868961 17179868963 17179868964 17179868965 17179868966 17179868969 17179868971 17179868972 17179868974 17179868975 17179868977 17179868978 17179868980 17179868981 17179868983 17179868984 17179868986 17179868987 17179868989 17179868990 17179868994 17179868995 17179868997 17179868998 17179868999 17179869000 17179869001 17179869002 17179869004 17179869005 17179869007 17179869024 17179869025 17179869026 17179869028 17179869029 17179869031 17179869032 17179869035 17179869037 17179869038 17179869039 17179869040 17179869041 17179869043 17179869044 17179869046 17179869049 17179869050 17179869051 17179869052 17179869054 17179869057 17179869059 17179869060 17179869061 17179869062 17179869065 17179869066 17179869067 17179869068 17179869070 17179869071 17179869072 17179869073 17179869074 17179869076 17179869079 17179869080 17179869082 17179869083 17179869085 17179869086 17179869087 17179869104 17179869106 17179869107 17179869109 17179869110 17179869111 17179869112 17179869113 17179869116 17179869117 17179869120 17179869141 17179869162";
	std::istringstream stream(str);
	std::vector<uint32_t> vect;
	while (!stream.eof()) {
		uint64_t val;
		stream >> val;
		vect.push_back(val & 0xFFFFFFFF);
	}
	std::vector<uint32_t> orig = vect;
	std::vector<uint8_t> buffer(1024 * 1024);
	int size = FrontierCompression::Encode(vect.size(), &vect[0], &buffer[0], buffer.size());

	std::vector<uint32_t> vect2(400);
	int pos = FrontierCompression::Decode(size, &buffer[0], &vect2[0], 400);
	EXPECT_EQ(pos, orig.size());
	ensure(pos == orig.size());
	for (int i = 0; i < pos; i++) EXPECT_EQ(orig[i], vect2[i]);
}

TEST(TestFrontierCompression, TectCompression_OutOfOrder) {
	std::vector<uint32_t> vect{ 100, 10000, 2500, 2, 20000 };
	std::vector<uint8_t> buffer(1024 * 1024);
	int size = FrontierCompression::EncodeBitMapWithCheck(vect.size(), &vect[0], &buffer[0], buffer.size());
	EXPECT_EQ(size, -1);
}

TEST(TestFrontierCompression, TectCompression_SameBeginningEnd) {
	std::vector<uint32_t> vect{ 100, 10000, 2500, 2, 100 };
	std::vector<uint8_t> buffer(1024 * 1024);
	int size = FrontierCompression::EncodeBitMapWithCheck(vect.size(), &vect[0], &buffer[0], buffer.size());
	EXPECT_EQ(size, -1);
}
